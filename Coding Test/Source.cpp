//#include<iostream>
//#include<vector>
//using namespace std;
//
//int K;						// 트리 깊이
//vector<int> inorder;		// 중위 순회 결과 저장 벡터
//vector<vector<int>> levels;	// 각 레벨의 노드 저장
//
//// 트리 복원 함수
//void buildTree(int start, int end, int depth) {
//	// 기저 사례 범위 제한
//	if (start > end) return;
//	// 중간값 = 루트
//	int mid = (start + end) / 2;
//	// 해당 레벨 깊이에 노드 추가
//	levels[depth].push_back(inorder[mid]);
//
//	// 왼쪽 서브트리 재귀
//	buildTree(start, mid - 1, depth + 1);
//	// 오른쪽 서브트리 재귀
//	buildTree(mid + 1, end, depth + 1);
//}
//
//int main() {
//	// K 입력
//	cin >> K;
//	// 총 노드 크기
//	int numNodes = (1 << K) - 1; // 2^K - 1 개의 노드 (총 노드)
//	// 중위 순회에 총 노드 크기 적용
//	inorder.resize(numNodes);
//	// 각 레벨 노드 K 크기 적용
//	levels.resize(K);
//
//	// 중위 순회 결과 입력
//	for (int i = 0; i < numNodes; i++) {
//		cin >> inorder[i];
//	}
//
//	// 트리 구축
//	buildTree(0, numNodes - 1, 0);
//
//	// 출력
//	for (int i = 0; i < K; i++) {
//		for (int val : levels[i]) {
//			cout << val << " ";
//		}
//		cout << "\n";
//	}
//
//	return 0;
//}

//#include <iostream>
//#include <vector>
//using namespace std;
//
//int n, r, parent, root;			// 노드 개수, 삭제 노드, 부모 정보, 루트 표시
//vector<int> tree[54];	// 트리 표현 인접 리스트
//
//int dfs(int here) {
//	int leaf = 0;	// 리프 노드 개수 변수
//	int child = 0;	// 자식 노드 개수 변수
//
//	for (int there : tree[here]) {	// 현재 노드 here 순회
//		if (there == r) continue;	// 만약 순회 중인 노드가 삭제 노드면 패스
//		leaf += dfs(there);			// 자식 노드가 있다면, 해당 자식에 리프 노드 개수를 더함
//		child++;					// 자식 노드 기록
//	}
//
//	if(child == 0) return 1;		// 자식이 없으면 리프노드로 1 반환
//	return leaf;					// 자식 있으면 리프 노드 개수를 반환
//}
//
//int main() {
//	
//	cin >> n;
//
//	for (int i = 0; i < n; i++) {
//		cin >> parent;
//
//		if (parent == -1) root = i;		// -1인 경우 루트 노드
//		else tree[parent].push_back(i);	// 루트가 아니면 그 부모의 자식 리스트에 추가
//	}
//
//	cin >> r;
//
//	if (r == root) {		// 삭제 노드가 루트 노드라면
//		cout << 0 << "\n";	// 모든 트리 삭제되므로 리프 노드 0개
//		return 0;			// 프로그램 종료
//	}
//
//	cout << dfs(root) << "\n";	// 루트 노드부터 DFS 탐색 시작, 리프 노드 개수 출력
//
//	return 0;
//}

//return (childCount == 0) ? 1 : leafCount; // 자식이 없으면 리프 노드

# RAII와 동적메모리 자원 관리

### ❓** 면접 질문 예시 : RAII란 무엇인가요 ? **

🧠 * *답변 예시 : **

RAII(Resource Acquisition Is Initialization)는 C++에서 자원 관리에 사용되는 설계 패턴으로, ** 자원의 생애 주기를 객체의 생애 주기에 결합시키는 방식** 입니다.

즉, 객체가 생성될 때 자원을 획득하고(예 : 동적 메모리, 파일 핸들, 락 등), 객체가 소멸될 때 자원을 자동으로 해제하는 구조입니다.

이 방식은** 자원의 누수나 예외 처리 누락 문제를 방지** 할 수 있게 해줍니다.대표적인 예로 `std::unique_ptr`, `std::lock_guard`, `std::ofstream` 등이 있습니다.

RAII 덕분에 try - catch 없이도 예외가 발생해도 자원이 자동으로 정리되며, 객체의 스코프에 따라 자원 해제가 자동으로 일어나기 때문에** 안정성과 유지 보수성** 이 높아집니다.

-- -

### ❓ * *RAII가 왜 필요한가요 ? **

🧠 * *답변 예시 : **

RAII가 필요한 이유는 * *수동으로 자원을 관리할 때 발생할 수 있는 누수, 예외 처리 누락, 복잡성 증가** 문제를 해결해주기 때문입니다.

예를 들어 `new`로 동적 할당한 뒤 `delete`를 깜빡하면 메모리 누수가 발생합니다.하지만 `std::unique_ptr`처럼 RAII를 사용하는 클래스는 스코프를 벗어날 때 자동으로 자원을 해제하므로** 코드가 간결해지고 안전성이 향상됩니다.**

-- -

### ❓ * *RAII를 사용한 예시를 말해보세요.* *

🧠 * *답변 예시 : **

대표적인 RAII 예시는 `std: : lock_guard`입니다. `std::mutex`와 함께 사용할 때 다음과 같이 작성합니다 :

```cpp
std::mutex mtx;

void func() {
    std::lock_guard<std::mutex> lock(mtx); // 여기서 락 획득
    // 임계 구역 작업
} // 함수 끝나면서 자동으로 락 해제
```

이 경우 예외가 발생하더라도 `lock_guard` 객체가 소멸되면서 mutex가 자동으로 해제되기 때문에 deadlock을 방지할 수 있습니다.

V## ✅** 프로세스 vs 스레드, 락, 데드락, 세마포어 개념 정리**

-- -

### ❓ Q1. * *프로세스와 스레드의 차이점은 무엇인가요 ? **

🧠 * *답변 예시 : **

-*프로세스(Process) * *는 실행 중인 프로그램 단위로, ** 독립적인 메모리 공간(코드, 데이터, 힙, 스택)을 가집니다.**

같은 프로그램을 여러 번 실행하면 각각 다른 프로세스가 됩니다.

- 실제 물리 메모리 사용량과는 상관없이 프로세스 자신이 전체 메모리를 전부 가진 것처럼 작동해 이러한 착각을 지원하기 위해 가상 메모리 할당과 페이징 같은 기능을 제공

- *스레드(Thread) * *는 프로세스 내의 실행 흐름 단위이며,
-**코드, 데이터, 힙은 공유** 하지만** 레지스터와 스택은 각각 독립** 적으로 가집니다.
- 스레드의 컨텍스트 스위칭 기법 : FCFS, RR(Round - Robin:시분할), SJF 등
- 메모리 공유로 그에 따른 데이터 레이스, 데드락 문제를 피할 수 없어 Lock이나 Atomic을 사용해 잘 회피해야함.
- 스레드는 일정 시간 경과나 IO 인터럽트나 Sleep 등의 코드 실행, CPU 점유 양보(Yield) 등의 이유로 스위칭 될 수 있음.

** 비교 요약 : **

| 구분 | 프로세스 | 스레드 |
| -- - | -- - | -- - |
| 메모리 | 독립된 가상 메모리 공간 | 프로세스 내 힙 / 데이터 공유 |
| 통신 | IPC 필요 or 공유 메모리 방식 사용 | 메모리 공유로 빠름 |
| 생성 / 소멸 비용 | 상대적으로 무거움 | 가벼움 |
| 컨텍스트 스위칭 | 비용 큼(필요 정보가 많음) | 비용 적음 |
| 안정성 | 하나 죽어도 다른 프로세스 영향 없음 | 하나가 죽으면 프로세스 전체 영향 |

-- -

### ❓ Q2. * *멀티스레드 환경에서 발생할 수 있는 문제는 무엇인가요 ? **

🧠 * *답변 예시 : **

멀티스레드는 * *메모리를 공유 * *하므로, 동기화가 없으면** Data Race**, ** Deadlock** 같은 문제가 발생할 수 있습니다.

이를 방지하기 위해 `Lock`, `Atomic`, `Mutex`, `Semaphore` 등을 사용해 동기화해야 합니다.

-- -

### ❓ Q3. * *데드락이란 무엇이며, 언제 발생하나요 ? **

🧠 * *답변 예시 : **

-*데드락(Deadlock) * *은 두 개 이상의 스레드가 * *서로 자원을 점유한 채, 상대 자원을 기다리면서 무한 대기하는 상황** 입니다.

예를 들어, 스레드 A는 자원 1을, 스레드 B는 자원 2를 점유한 상태에서

서로 상대의 자원을 필요로 할 경우 발생합니다.

* *발생 조건(4가지) :**

1. * *상호 배제 * *: 한 번에 한 스레드만 자원 점유
2. * *점유와 대기 * *: 자원을 가진 상태에서 다른 자원 요청
3. * *비선점 * *: 점유한 자원을 강제로 뺏을 수 없음
4. * *순환 대기 * *: 스레드들이 원형 형태로 자원 기다림

-- -

### ❓ Q4. * *락(Lock)이란 무엇이고, 왜 필요하나요 ? **

🧠 * *답변 예시 : **

-*락(Lock) * *은 * *동시에 여러 스레드가 공유 자원에 접근하지 못하게 막는 장치 * *입니다.

한 스레드가 락을 획득하면, 나머지는 락이 해제될 때까지 대기합니다.

이를 통해 Data Race 방지와** 임계 구역(Critical Section)** 보호가 가능합니다.

-- -

### ❓ Q5. * *세마포어(Semaphore)란 무엇인가요 ? **

🧠 * *답변 예시 : **

**세마포어 * *는 * *공유 자원 접근 수를 제어하는 정수형 동기화 객체 * *입니다.

임계 구역 진입 전 `P(Wait)` 연산, 종료 시 `V(Signal)` 연산을 사용합니다.

- `P`: 자원 수 감소. 0이면 대기
- `V`: 자원 수 증가.대기 중인 스레드 깨움

* *종류:**

-**Binary Semaphore(0 또는 1) * *이진→ Mutual Exclusion(**Mutex)와 동일 * *
-**Counting Semaphore(0 이상) * *계수형 → 여러 자원 제어 가능

* *예시 비유 : **

-**세마포어 * *: 화장실 여러 개 + 입장 인원 수 제어
- **뮤텍스 * *: 화장실 1개 + 열쇠 1개

-- -

### ❓ Q6. * *Mutex와 Semaphore의 차이는 무엇인가요 ? **

🧠 * *답변 예시 : **

| 항목 | Mutex | Semaphore |
| -- - | -- - | -- - |
| 자원 수 | 1개(Binary) | 여러 개 가능(Counting) |
| 사용 주체 | **스레드가 소유 * *| **자원을 관리 * *|
| 소유권 | 있음 | 없음 |
| 사용 목적 | 임계 구역 보호 | 공유 자원 접근 수 제한 |
| 예시 비유 | 1인 화장실 키 | 다인 입장 제한 화장실 |

-- -

### ❓ Q7. * *세마포어를 잘못 설계했을 때 데드락이 발생할 수 있나요 ? **

🧠 * *답변 예시 : **

네, ** 세마포어를 여러 개 사용하는 상황에서 잘못된 순서로 자원을 요청하면 데드락이 발생할 수 있습니다.**

예 :

    스레드 A → `P(s)`, `P(q)`

    스레드 B → `P(q)`, `P(s)`

    → 서로 자원을 점유한 채, 상대 자원을 기다리면 데드락 발생.

    ** 해결 방법 : **

    -자원 요청 순서 통일
    - 모든 자원을 한 번에 획득
    - 타임아웃 또는 자원 반납 후 재시도

    -- -

    ### ✅ C++에서의 스레드 및 락 구현 방법

    C++에서 멀티스레딩을 구현하는 대표적인 방법은 크게 두 가지입니다 :

1. * *Windows API 기반 스레드 * *
-`_beginthreadex`, `WaitForSingleObject`, `CloseHandle` 등을 활용해 스레드를 생성하고 동기화할 수 있습니다.
- 저수준의 제어가 가능하지만 코드가 복잡하고 관리가 어렵습니다.
2. * *C++11 표준 스레드 라이브러리 * *
-`std::thread`, `std::mutex`, `std::lock_guard` 등을 사용해 간단하고 직관적인 방식으로 멀티스레딩을 구현할 수 있습니다.
- 크로스 플랫폼이며 가독성이 좋고 유지보수가 쉽습니다.

### ✅ 예시 : 뮤텍스를 사용한 멀티스레드 카운터

```cpp
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;            // 공유 자원
std::mutex mtx;             // 뮤텍스 객체

void addCount(const std::string& threadName) {
    for (int i = 0; i < 10000; ++i) {
        std::lock_guard<std::mutex> lock(mtx); // 임계 영역 보호 유/무 차이 출력
        ++counter;
    }
    std::cout << threadName << " done\n";
}

int main() {
    std::thread t1(addCount, "Thread 1");
    std::thread t2(addCount, "Thread 2");

    t1.join(); // 스레드 종료 대기
    t2.join();

    std::cout << "Final Counter: " << counter << std::endl;
    return 0;
}
```

🔍 코드 설명

- `counter`는 두 스레드가 동시에 접근하는 * *공유 자원 * *입니다.
- `std::mutex`를 통해 임계 영역을 보호하여 * *데이터 레이스(Data Race) * *를 방지합니다.
- `std::lock_guard`는 스코프 기반 락(스코프를 벗어나면 자동 unlock)으로 예외가 발생해도 안전합니다.

-- -

💡 출력 예시

```cpp
Thread 1 done
Thread 2 done
Final Counter : 20000
```

뮤텍스로 보호하지 않았을 경우 실행할 때마다 출력이 다르게 나온다(운 좋게 예상 값이 나오기도함)

두 스레드가 동시에 counter를 읽어서 서로 덮어쓰게 됨 → 경쟁 상태(레이스 컨디션) 발생

-- -

### ✅ 가상 메모리 할당(Virtual Memory Allocation)

    > 프로세스마다 실제 메모리(RAM)와 독립된 주소 공간을 사용하는 방식
>

-- -

**📌 핵심 개념 * *

-물리 메모리의 한계를 가상 주소 공간으로 확장
- 프로그램은 연속된 메모리를 사용하는 것처럼 보이나, 실제로는** 페이지 단위로 분산 저장**
-OS는 주소 변환(가상→물리)을 수행
- **보호 / 격리**, ** 메모리 절약**, ** 멀티 프로세스 지원** 가능

-- -

**🧠 장점 * *

-실제 메모리보다 큰 프로그램 실행 가능
- 다른 프로세스의 메모리에 접근 불가(보안성)
- 스와핑 / 페이징을 통해 메모리 효율 증가

-- -

### ✅ 페이징(Paging)

> 가상 메모리를 고정 크기 페이지로 나누고, 물리 메모리에도 프레임 단위로 나눠 매핑하는 방식
>

-- -

**📌 구조 * *

-가상 메모리 : `페이지(Page)`
- 물리 메모리 : `프레임(Frame)`
- 페이지 테이블 : 페이지 → 프레임 변환 매핑

-- -

**🧠 목적 * *

-외부 단편화 제거
- 메모리 관리 단순화
- 프로세스마다 주소 공간을 유연하게 분리

-- -

**💥 페이지 폴트(Page Fault) * *

-필요한 페이지가 메모리에 없을 경우 발생 → 디스크에서 불러옴(속도 저하 원인)

-- -

### ✅ 라운드 로빈(Round - Robin)

> 프로세스 스케줄링 알고리즘 중 하나로, 모든 프로세스에 순차적으로 동일한 CPU 시간 할당
>

-- -

**📌 특징 * *

-**공정성 보장**, 굶주림(Starvation) 방지
- 시간 단위 : `Time Quantum` (시간 할당량)

-- -

**🧠 작동 방식 * *

1. 큐에 프로세스를 순서대로 저장
2. 시간 할당량만큼 실행 후 → 다음 프로세스로 전환
3. 완료되지 않았으면 다시 큐 뒤에 추가

-- -

**💡 단점 * *

-시간 할당량이 작으면 → 과도한 문맥 교환(비효율)
- 크면 → 응답 시간 증가

-- -

### ✅ 임계구역(Critical Section)

> 둘 이상의 스레드가 동시에 접근하면 문제가 발생할 수 있는 공유 자원 접근 영역
>

-- -

**📌 예시 * *

-공유 변수, 파일, 네트워크, 게임에서의 캐릭터 상태 등

-- -

**🛠️ 해결이 필요한 이유 * *

-데이터 무결성 유지
- 멀티스레드에서 동기화 필수

-- -

**✅ 해결 방법 * *

-뮤텍스(Mutex)
- 세마포어(Semaphore)
- 스핀락(Spinlock)
- atomic 연산 등

-- -

### ✅ 상호 배제 알고리즘(Mutual Exclusion Algorithm)

> 둘 이상의 프로세스 / 스레드가 동시에 임계구역에 진입하지 못하도록 보장하는 알고리즘
>

-- -

**📌 목적 * *

-한 번에 오직 하나의 프로세스만 임계구역 실행 가능하도록

-- -

**🧠 대표 알고리즘 * *

-**Peterson's Algorithm** (2개 프로세스에 사용 가능)
- **Dekker's Algorithm**
- **Lamport's Bakery Algorithm** (N개 프로세스 확장 가능)
- 실제 시스템에서는 `lock`, `mutex`, `atomic` 등으로 구현

-- -

**🎮 게임 개발과의 연관성 * *

-네트워크 동기화, 멀티스레드 렌더링, 물리 연산 등에서 필수
- 자원 동시 접근 시 데이터 손상 방지를 위해 적용됨

-- -

### ✅ 아토믹(Atomic)이란 ?

> 하나의 연산이 중간에 끼어들 수 없이, "원자적으로" 완전히 실행되거나 안 되거나만 하는 연산
>

-- -

📌 핵심 개념

- "원자성"이란 * *불가분성 * *을 뜻함
- 여러 스레드에서 동시에 실행되어도 * *데이터 레이스 없이 안전함 * *
-중간에 다른 스레드가 끼어들 수 * *없도록 보장 * *
-락(mutex) 없이도 * *스레드 간 동기화 * *가능

-- -

💥 왜 필요할까 ?

멀티스레드 환경에서 아래 코드는 문제가 될 수 있어요 :

```cpp
int counter = 0;

void ThreadFunc() {
    for (int i = 0; i < 10000; ++i)
        counter++;  // 비원자적 연산 → 데이터 레이스 발생 가능
}
```

`counter+ + `는 사실 3단계로 구성됨 :

1. 값 읽기
2. 값 증가
3. 값 쓰기

→ 다른 스레드가 중간에 끼어들면 값이 꼬일 수 있음 😢

-- -

🛠️ 해결 : `std: : atomic`

```cpp
#include <atomic>

std::atomic<int> counter = 0;

void ThreadFunc() {
    for (int i = 0; i < 10000; ++i)
        counter++;  // 원자적으로 처리됨 (데이터 레이스 X)
}
```

- `std::atomic`은 내부적으로 * *CPU 명령어 수준에서 원자성 보장 * *
-락 없이도 안전하지만, ** 성능도 빠름**

-- -

🎮 게임 개발과의 연관성

- **멀티스레드 엔진 구조 * *에서 * *상태 플래그나 카운터 * *를 안전하게 관리
- **동시성 큐**, ** 이벤트 플래그**, ** 레퍼런스 카운트** 등에 사용됨
- 락을 사용하지 않아 * *프레임 드랍 최소화 * *가능

-- -

⚖️ atomic vs mutex

| 항목 | atomic | mutex |
| -- - | -- - | -- - |
| 성능 | 빠름 | 상대적으로 느림 |
| 락 오버헤드 | 없음 | 있음 |
| 복잡한 연산 | 어려움 | 가능 |
| 데드락 위험 | 없음 | 있음 |
| 사용 용도 | 단순 변수, 카운터 | 임계구역, 복합 연산 |

## ✅ 조명(Lighting)

-- -

### 🔹 * *Global Illumination(GI) * *

### 📘 개념 정리

- **직접광 + 간접광 * *을 모두 계산하는 기술.
- 주된 방식 : **라이트맵 * *(정적), ** 레이트레이싱 GI** (실시간).
- **언리얼 엔진 * *은 Lumen(실시간 GI)과 Lightmass(정적 GI)를 모두 지원.

### ❓ 예상 질문

Q.언리얼 엔진에서 GI(Global Illumination)는 어떤 방식으로 구현되며, 실시간 GI의 장단점은 ?

### 💬 답변

언리얼 5부터는 * *Lumen * *을 통해 실시간 GI를 지원합니다.움직이는 오브젝트나 조명 변화에 즉각 반응할 수 있어 동적인 씬에 적합하지만, 성능 비용이 크기 때문에 플랫폼에 따라** Lightmass 라이트맵** 을 사용하는 것이 여전히 일반적입니다.Lightmass는 정적 오브젝트 기준의 조명을 미리 계산하여 고정된 조명 정보를 저장합니다.

-- -

### 🔹 * *라이트맵(Lightmap) * *

### 📘 개념 정리

- 조명을 * *미리 계산 * *해서 텍스처 형태로 저장한 방식.
- 정적인 환경에서 성능 효율이 매우 좋음.
- 언리얼에선 Lightmass를 통해 베이크 가능.

### ❓ 예상 질문

Q.라이트맵의 장점과 단점은 무엇이며, 언제 사용하나요 ?

### 💬 답변

라이트맵은 빛의 간접 반사까지 미리 계산하여 성능 부담 없이 사용할 수 있는 방식입니다.주로 * *실내 배경**, ** 정적 오브젝트** 에서 사용되며, 빛의 방향이나 오브젝트 위치를 바꾸면 다시 베이크해야 하는 단점이 있습니다.** LOD** 나 섀도우 품질 관리에 민감하게 사용됩니다.

-- -

### 🔹 * *Ray Traced GI * *

### 📘 개념 정리

- 빛의 경로를 실제처럼 시뮬레이션하여 반사, 굴절, 간접광까지 표현.
- 매우 사실적이나 연산량이 많음.

### ❓ 예상 질문

Q.언리얼에서 레이트레이싱을 활용한 GI는 어떤 상황에서 유리한가요 ?

### 💬 답변

언리얼 4.26부터 레이트레이싱 기능이 강화되었으며, 사실적인 반사 및 조명 표현이 필요한** 건축 시각화**, ** 시네마틱**, ** 실사 기반 프로젝트** 에 주로 사용됩니다.하지만 실시간 게임에서는 여전히** Lumen** 또는** 라이트맵** 을 더 많이 활용합니다.

-- -

## ✅ 조명 알고리즘

-- -

### 🔹 * *Ambient Light(환경광) * *

### 📘 개념 정리

- 직접적인 광원이 닿지 않는 어두운 영역에 은은하게 퍼지는 빛.
- 현실에서는 GI로 표현되지만, 전통적인 방식에서는 일정 상수값으로 더함.

### ❓ 예상 질문

Q.Ambient Light는 실제 빛을 시뮬레이션하는 건가요 ?

### 💬 답변

Ambient Light는 실제 물리적 광원이라기보다 * *빛이 어느 정도는 있을 것이다 * *라는 가정하에 추가되는 일정한 값입니다.언리얼 머티리얼에서는 Emissive나 AO(Ambient Occlusion) 등을 통해 유사한 효과를 낼 수 있으며, 실제 GI가 구현되면 더 자연스럽게 표현됩니다.

-- -

### 🔹 * *Diffuse Light(난반사광) * *

### 📘 개념 정리

- 물체 표면이 * *빛을 고르게 반사 * *하는 현상.
- 조명과 노멀벡터 간 각도로 휘도를 결정함(Cosine 법칙 사용).
- Lambert 모델 기반.

### ❓ 예상 질문

Q.난반사광은 어떤 방식으로 계산되며, 어떤 요소가 중요하나요 ?

### 💬 답변

난반사광은 광원과 표면의 * *법선 벡터 * *간의 각도에 따라 결정되며, cos(θ) 값을 곱하여 계산합니다.언리얼 엔진의 셰이딩 모델 내부에서 처리되며, 머티리얼 에디터에서는 직접 제어할 필요 없이 자동으로 적용됩니다.다만, 커스텀 셰이딩이나 특수 효과에서는 별도로 구현할 수 있습니다.

-- -

### 🔹 * *Specular Light(정반사광) * *

### 📘 개념 정리

- 거울처럼 반사되어 빛이 * *눈 방향과 일치할 때 * *강하게 보이는 하이라이트.
- 반사 벡터와 시선 벡터를 비교해 계산.

### ❓ 예상 질문

Q.스페큘러 하이라이트는 어떻게 계산되고, 무엇이 필요하나요 ?

### 💬 답변

스페큘러는 반사 벡터와 시선 벡터의 각도 차이에 따라 밝기를 결정하며, ** 반사 벡터** 를 계산하는 것이 핵심입니다.이때 사용되는 모델은 Phong 또는 Blinn - Phong이며, 언리얼에서는 Roughness 값으로 하이라이트의 날카로움을 조절할 수 있습니다.시네마틱 품질이 필요한 게임에서 자주 강조됩니다.

-- -

## ✅ 범프 매핑 / 노말 매핑(Bump / Normal Mapping)

-- -

### 🔹 * *Normal Mapping * *

### 📘 개념 정리

- 실제로 메쉬의 기하 구조를 바꾸지 않고, ** 조명 계산 시 법선 방향만 수정** 하여 입체감을 표현하는 기술.
- 픽셀마다 다른 노말 정보를 사용.

### ❓ 예상 질문

Q.언리얼에서 노말 맵은 어떤 방식으로 작동하고, 어떤 효과를 주나요 ?

### 💬 답변

노말 맵은 각 픽셀마다 조명에 반응하는 방향을 속이는 방식으로 * *디테일을 부여 * *합니다.예를 들어 거칠고 울퉁불퉁한 표면처럼 보이지만 실제 메시에는 변화가 없습니다.언리얼에서는 머티리얼의 Normal 입력에 노말 텍스처를 연결하면 자동으로 처리되며, 퍼포먼스를 유지하면서 사실감을 줄 수 있습니다.

### 추가 공부 : https://www.slideshare.net/slideshow/bump-mapping-164480242/164480242