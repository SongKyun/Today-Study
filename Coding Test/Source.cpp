//#include<iostream>
//#include<vector>
//using namespace std;
//
//int K;						// 트리 깊이
//vector<int> inorder;		// 중위 순회 결과 저장 벡터
//vector<vector<int>> levels;	// 각 레벨의 노드 저장
//
//// 트리 복원 함수
//void buildTree(int start, int end, int depth) {
//	// 기저 사례 범위 제한
//	if (start > end) return;
//	// 중간값 = 루트
//	int mid = (start + end) / 2;
//	// 해당 레벨 깊이에 노드 추가
//	levels[depth].push_back(inorder[mid]);
//
//	// 왼쪽 서브트리 재귀
//	buildTree(start, mid - 1, depth + 1);
//	// 오른쪽 서브트리 재귀
//	buildTree(mid + 1, end, depth + 1);
//}
//
//int main() {
//	// K 입력
//	cin >> K;
//	// 총 노드 크기
//	int numNodes = (1 << K) - 1; // 2^K - 1 개의 노드 (총 노드)
//	// 중위 순회에 총 노드 크기 적용
//	inorder.resize(numNodes);
//	// 각 레벨 노드 K 크기 적용
//	levels.resize(K);
//
//	// 중위 순회 결과 입력
//	for (int i = 0; i < numNodes; i++) {
//		cin >> inorder[i];
//	}
//
//	// 트리 구축
//	buildTree(0, numNodes - 1, 0);
//
//	// 출력
//	for (int i = 0; i < K; i++) {
//		for (int val : levels[i]) {
//			cout << val << " ";
//		}
//		cout << "\n";
//	}
//
//	return 0;
//}

//#include <iostream>
//#include <vector>
//using namespace std;
//
//int n, r, parent, root;			// 노드 개수, 삭제 노드, 부모 정보, 루트 표시
//vector<int> tree[54];	// 트리 표현 인접 리스트
//
//int dfs(int here) {
//	int leaf = 0;	// 리프 노드 개수 변수
//	int child = 0;	// 자식 노드 개수 변수
//
//	for (int there : tree[here]) {	// 현재 노드 here 순회
//		if (there == r) continue;	// 만약 순회 중인 노드가 삭제 노드면 패스
//		leaf += dfs(there);			// 자식 노드가 있다면, 해당 자식에 리프 노드 개수를 더함
//		child++;					// 자식 노드 기록
//	}
//
//	if(child == 0) return 1;		// 자식이 없으면 리프노드로 1 반환
//	return leaf;					// 자식 있으면 리프 노드 개수를 반환
//}
//
//int main() {
//	
//	cin >> n;
//
//	for (int i = 0; i < n; i++) {
//		cin >> parent;
//
//		if (parent == -1) root = i;		// -1인 경우 루트 노드
//		else tree[parent].push_back(i);	// 루트가 아니면 그 부모의 자식 리스트에 추가
//	}
//
//	cin >> r;
//
//	if (r == root) {		// 삭제 노드가 루트 노드라면
//		cout << 0 << "\n";	// 모든 트리 삭제되므로 리프 노드 0개
//		return 0;			// 프로그램 종료
//	}
//
//	cout << dfs(root) << "\n";	// 루트 노드부터 DFS 탐색 시작, 리프 노드 개수 출력
//
//	return 0;
//}

//return (childCount == 0) ? 1 : leafCount; // 자식이 없으면 리프 노드

### 🔸** 면접 질문 예시**

### 🔹 Q1. `vector`와 `list`의 차이점을 설명해보세요.

** A.* *

-`vector`는 연속된 메모리를 사용하는 * *동적 배열 * *입니다.

따라서 * *임의 접근(random access) * *이 가능하고, ** 캐시 친화적** 이라 읽기 성능이 좋습니다.

- 반면, `list`는 노드들이 포인터로 연결된** 연결 리스트** 구조로 되어 있어, ** 임의 접근은 불가능** 하고

요소를 순차적으로 접근해야 합니다.

대신 삽입과 삭제는** 상수 시간** 에 가능합니다.

- 정리하면,

`vector`는** 읽기 성능이 중요할 때**,

`list`는** 삽입 / 삭제가 빈번할 때 * *적합합니다.


-- -

### 🔹 Q2. `map`과 `unordered_map`의 차이를 설명해보세요.

* *A.* *

-`map`은 내부적으로 * *레드 - 블랙 트리(Red - Black Tree) * *구조이며,

모든 연산이** O(log n)** 시간에 수행되고,

키에 따라** 자동 정렬** 되는 특징이 있습니다.

- 반면, `unordered_map`은** 해시 테이블** 기반으로,

키를 해싱하여 저장하므로, ** 정렬은 안 되지만**,

평균적으로 검색 / 삽입 / 삭제 연산이 * *O(1) * *의 빠른 속도를 가집니다.

- 메모리 측면에서는 `map`이 더 효율적일 수 있고,

`unordered_map`은 더 많은 메모리를 사용하지만** 속도** 가 우선시되는 경우에 사용됩니다.


-- -

### 🔹 Q3. `vector`에서 반복자 무효화가 발생하는 경우는 ?

**A.* *

-반복자 무효화는 * *메모리 재할당 * *또는 * *원소 이동 * *이 발생할 때 생깁니다.

대표적으로 `push_back`, `resize`, `insert`, `erase`에서 발생할 수 있습니다.

- `insert(pos)`의 경우,

** 삽입한 위치 이후의 반복자는 무효화** 되며,

삽입 위치보다 앞의 반복자는 메모리 재할당이 일어나지 않으면 유지됩니다.

- `erase(pos)`는

** 삭제 위치 이후 반복자 무효화**,

** 앞쪽 반복자는 유지** 됩니다.

- 따라서 안전하게 순회하려면,

`erase()`가 반환하는** 유효한 반복자** 를 사용하는 방식으로 구현해야 합니다.


-- -

### 🔹 Q4. `unordered_map`의 해시 충돌 해결 방식에는 어떤 것들이 있나요 ?

**A.* *

해시 충돌을 해결하는 대표적인 두 가지 방식이 있습니다.

1. * *체이닝(Chaining) * *
-같은 인덱스에 충돌한 요소를 * *연결 리스트 * *로 저장합니다.
- 구현이 간단하고, 성능 저하가 선형적으로 발생합니다.
2. * *개방 주소법(Open Addressing) * *
-충돌 시 * *다른 버킷을 찾아 저장 * *하는 방식입니다.
- 대표적인 기법은 다음과 같습니다 :
-**선형 탐색(Linear Probing) * *: 한 칸씩 다음 버킷 탐색
- **제곱 탐색(Quadratic Probing) * *: i² 간격으로 탐색
- **이중 해싱(Double Hashing) * *: 두 번째 해시 함수를 활용해 탐색 간격 결정
- 체이닝은 * *공간이 많이 필요 * *하지만 구현이 쉽고,

개방 주소법은** 추가 메모리가 필요 없고**,

데이터가 적을 때 유리합니다.


-- -

### 🔹 Q5. `map`에 동일한 키를 insert하면 어떻게 되나요 ?

**A.* *

-`map.insert()`는 항상

`pair<iterator, bool > `을 반환합니다.

- 이미 존재하는 키를 삽입하면

`bool`은 `false`, `iterator`는 기존 원소를 가리킵니다.

- 즉, 중복된 키의 삽입은** 무시** 되고,

기존 키에 대한 접근을 반환하게 됩니다.


-- -

## ✅ * *1. vector * *

### 🔹 * *특징 * *

-**동적 배열 * *구조(크기 조절 가능)
- 메모리 상에서 * *연속된 공간 * *→ * *캐시 친화적 * *
-**random access iterator 임의접근반복자 → 배열의 원소에 즉시 접근(빠름) * *

### 🔹 * *emplace_back vs push_back * *

-`emplace_back()`은 객체 생성(복제) 없이 바로 메모리에 생성

→ 복사 / 이동 생략 → * *성능 더 좋음 * *


-- -

### 🔹 * *반복자 * *

-컨테이너(vector, list 등)의 요소에 순차적으로 접근하기 위한 객체
- 일반 포인터처럼*, ++, — 등의 연산자 사용 가능, 포인터처럼 작동
- vector, list, map 등은 내부 구조가 서로 다름 → 하지만 반복자 사용으로 동일한 방식으로 요소 접근 가능
- ex) begin(), end(), rend() 등

** 🔹 요약**

-컨테이너 순회를 일반화하기 위한 도구
- 다양한 컨테이너를 동일한 방식으로 다룰 수 있게 해 줌
- 포인터처럼 작동하며, STL 알고리즘과 함께 자주 사용됨

-- -

### 🔹 * *반복자 무효화(Iterator Invalidation) * *

🔸 "무효화된다"는 의미

> 기존에 가리키고 있던 메모리 주소가 바뀌거나 삭제되었기 때문에,
>
>
> 그걸 계속 사용하면** 예상치 못한 동작** 이나** 에러** 가 발생할 수 있음.
>

🔸 예시로 보는 반복자 무효화

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = { 1, 2, 3 };
    auto it = v.begin();  // 첫 번째 요소 가리킴 (1)

    v.push_back(4);  // 메모리 재할당 발생 가능

    // it은 여전히 첫 요소를 가리킨다고 믿지만, 주소가 바뀌었을 수도 있음
    cout << *it << endl;  // ⚠️ 정의되지 않은 동작 가능 (무효화된 반복자 사용)
}
```

- `push_back`으로 인해 `vector`의 내부 메모리가 * *재할당 * *되면서

기존 `it`이 가리키는 주소는 * *더 이상 유효하지 않음 * *.


🔸 어떤 경우에 무효화가 발생할까 ?

| 연산 | 무효화 발생 가능성 |
| -- - | -- - |
| `push_back()` | **재할당이 발생하면 * *기존 반복자 / 포인터 / 참조 무효화 |
| `resize()` | 크기 변경으로 인해 내부 재할당 → * *무효화 * *|
| `insert()` | 삽입 위치 이후의 요소가 이동됨 → * *해당 반복자들 무효화 * *|
| `erase()` | 삭제된 위치 이후의 요소들이 앞당겨짐 → * *해당 반복자들 무효화 * *|

🔸 요약

- "무효화된다"는 건 = **더 이상 안전하게 접근 불가 * *
-무효화된 반복자, 포인터, 참조를 사용하면 →** 미정의 동작**
-컨테이너 조작 후에는 반복자를 * *다시 얻는 것 * *이 안전함

```cpp
it = v.begin();  // 다시 갱신해서 사용
```

-- -

## ✅ * *2. list * *

### 🔹 * *특징 * *

-**연결 리스트 * *(단방향 / 양방향) 반복자를 사용함
- 이로 인해 임의 접근이 불가능하므로 원소 접근 시 해당 위치까지 순회해야함
- 포인터로 서로를 연결한 구조
- **연속 메모리 아님 * *→ * *캐시 비우호적 * *
-**삽입 / 삭제 O(1) * *(중간 삽입도 상수 시간)

### 🔹 * *주의점 * *

-`advance()`는 임의 접근 처럼 보이지만 실제로** 순회 기반 구현**
-원소 접근은 느리나 * *삽입 / 삭제가 빈번한 구조에 적합 * *

-- -

## ✅ * *3. map * *

### 🔹 * *특징 * *

-내부 구조 : **Red - Black Tree(균형 이진 탐색 트리) * *
-이진 탐색으로 검색이 빠른 편
- 삽입, 삭제 시 균형트리이기 때문에 균형 유지를 위한 오버헤드가 발생
- 키 - 값 저장, `key` 기준** 자동 정렬 : 키로 검색해 값을 찾음**
-모든 연산 : **O(log n) * *

### 🔹 * *insert 시 동작 * *

-이미 존재하는 키 삽입 시 * *기존 원소 유지 * *
-리턴 값 : 해당 노드의 키 / 값을 리턴

```cpp
std::pair<iterator, bool> // 정확히는 이렇게 리턴함
```

- `iterator`: (= key, value) 삽입된 또는 기존 원소
- `bool`: 삽입 성공 여부(true = 신규 삽입, false = 중복)

-- -

## ✅ * *4. unordered_map * *

### 🔹 * *특징 * *

-내부 구조 : **해시 테이블로 구현된 해시 맵 * *

해시 테이블 : 데이터 구조 이름.key → index를 통해 버킷 배열에 값 저장

해시 맵 : 해시 테이블 기반(key, value) 저장 자료구조의 개념 또는 추상화

- **정렬 X**, 대신** 빠른 접근 O(1)** (평균)

### 🔹** 장점**

-정렬이 필요 없는 경우 `map`보다 빠름
- key → hash → 인덱스로 접근 → * *상수 시간 * *

### 🔹 * *구현 기법 * *

### 📌 * *해시 충돌 해결 방식 * *

| 방식 | 설명 |
| -- - | -- - |
| **체이닝(Chaining) * *| 충돌 시 * *리스트로 연결 * *구현(연결 리스트) 단순, 메모리 추가 필요 |
| **개방 주소법(Open Addressing) * *| 충돌 시 * *빈 버킷 탐색 * *하여 저장(포인터X, 추가저장공간X), 오버헤드 적음, 데이터 적을 때 유리 |

### 📌 해시 충돌 시 * *Open Addressing의 방식들 * *

| 방법 | 설명 |
| -- - | -- - |
| **Linear Probing(선형 탐색) * *| 한 칸씩 순차 탐색(i + 1, i + 2, …) |
| **Quadratic Probing(제곱 탐색) * *| 제곱 단위로 이동(i + 1², i + 2², …) |
| **Double Hashing(이중 해시) * *| **두 번째 해시 함수 * *로 이동 간격 결정 |

-- -

### ✅ * *map vs unordered_map 요약 * *

| 항목 | `map` | `unordered_map` |
| -- - | -- - | -- - |
| 내부 구조 | Red - Black Tree | Hash Table |
| 정렬 | O | X |
| 탐색 속도 | O(log n) | O(1) 평균 |
| 반복자 순서 | 정렬 순서 | 정렬 X |
| 메모리 효율 | 더 좋음 | 여유 공간 필요 |

-- -

### 🔸 추가 용어 설명

- **해시 함수(hash function) * *: key를 고정된 크기의 숫자로 변환
- **버킷(bucket) * *: 해시 테이블의 실제 저장 공간
- **충돌(collision) * *: 서로 다른 키가 같은 인덱스로 해시되는 경우

-- -

## 언오더드 맵(unordered map)

* *C++ 11 이전엔 정렬이 필요하지 않은 경우에도 std::map을 사용하여 불필요한 오버헤드를 감수해야 했다.또는 비표준 라이브러리의 hash_map 컨테이너를 사용해야 했다.그러다 표준에도 해시맵이 필요하다는 말이 많아졌는지 C++ 11에서 std::unordered_map이라는 컨테이너가 등장했고, 기존의 std::map과 달리 이진 탐색트리가 아닌 해시 테이블로 구현되어 있다.때문에 요소를 자동으로 정렬하지 않으며 요소의 검색, 삽입, 삭제 연산이 평균적으로 상수 시간에 가능하다. (std::set, std::unordered_set 도 동일한 관계)[unordered_map의 내부 동작]기본적으로 해시맵과 동일하므로 해시맵의 동작 방식을 살펴보자.앞으로 해시맵 또는 그냥 맵(map)이라고 부르자.일단 map이라는 것은 key에 value를 매칭시켜 pair(쌍) 형태로 데이터를 저장하는 연관 컨테이너이다.따라서 각 요소는 pair<key, value> 형태로 저장되며 우리는 key를 통해 value에 접근할 수 있다.* *

![](https://blog.kakaocdn.net/dn/z5f3g/btqCKArilrg/akGvKzkWwAiMbopryyMIlK/img.png)

**여기까진 맵의 기본적인 특징이고, 해시맵의 특징은 바로 key를 통한 value로의 접근이 빠르다는 것이다.그 이유가 바로 hash 때문이다.hash는 다음과 같이 어떤 데이터를 특정 연산을 통해 특별한 값(보통 integer)으로 변환시켜주는 개념이다.* *

![](https ://blog.kakaocdn.net/dn/bPmCmW/btqCKg7E8OY/SwYFvXkxemJI6XzRraECmK/img.png)

    **hash 연산을 하는 함수를 해시 함수라 하며 해시 알고리듬은 MD5, SHA 같의 여러 종류의 알고리듬이 존재한다.해시맵은 해시 함수를 통해 key를 특정 값으로 변환시키고 이 값을 value를 저장할 공간의 인덱스로 사용한다.저장되는 공간은 보통 bucket 또는 slot이라고 부르며 다음 그림과 같이 저장된다.* *

    ![](https ://blog.kakaocdn.net/dn/bGm0cS/btqCNFEUyk9/2rcyQv7sG3opNYivGmS9zK/img.png)

        **"Hi" 라는 데이터를 동일한 해시 함수에 넣으면 항상 23이라는 데이터를 반환한다.사실 함수마다 다르지만 원래는 해시 함수의 반환값을 bucket size로 나눈 나머지(mod) 값을 인덱스로 사용하는 방법도 있다.그러면 무조건[0, bucket size) 범위의 인덱스가 나오니까.어쨌든 이는 key를 통해 value가 저장된 인덱스에 상수 시간에 접근할 수 있다는 걸 뜻한다.즉 O(1)의 시간복잡도를 가진다는 말이다.key - value 쌍이 10개든 100개든 1000개든 해시 함수 한번에 value의 index를 얻을 수 있기 때문이다.물론 사용하는 해시 함수의 시간 복잡도가 key - value 쌍의 개수에 영향을 받아선 안될 것이다.~~(그럴 일이 있나 싶겠지만)~~해시 함수가 아닌 key를 직접 비교해가며 value를 찾는다면 위 그림에선 24번 비교해야 23번 인덱스의 값에 접근할 수 있을 것이다.* *

    **정리해보면 만약 "Apple" - "Samsung"을 쌍으로 저장하고 싶다면 "Apple"을 해시 함수에 넣어 인덱스를 얻고 그 인덱스에 "Samsung"이라는 value를 저장한다.만약 "Apple"의 value를 읽어오고 싶다면 똑같이 "Apple"을 해시 함수에 넣어 인덱스를 얻은 뒤 bucket에서 읽어오면 된다.참고로 역은 성립하지 않아서 해시값을 통해 역으로 "Hi"라는 데이터에 접근할 순 없다.* *